# 다중 처리기 스케줄링 (Multiple-Processor Scheduling)

- 여러 개의 CPU가 있는 다중 처리기에서 스케줄링은 더 복잡
- 여러 스레다 병렬로 실행되어 부하 공유 가능
- 다중 처리기 스케줄링에서는 아래 이슈를 고려
    - 대칭/비대칭 다중 처리
    - 처리기 친화성
    - 부하 균등화
    - SMT

### 대칭/비대칭 다중 처리

- 비대칭 다중 처리(asymmetic multiprocessing)
    - 주 서버(master server)라는 하나의 처리기가 모든 스케줄링 결정과 입/출력 처리 그리고 다른 시스템의 활동을 취급
    - 다른 처리기들은 다만 사용자 코드만을 수행
    - 단지 한 처리기만 시스템 자료 구조를 접근하여 자료 공유의 필요성을 배제하기 때문에 간단
- 대칭 다중 처리(symmetric multiprocessing, SMP)
    - 각 처리기가 독자적으로 스케줄링
    - 스케줄링은 각 처리기의 스케줄러가 준비 완료 큐를 검사해서 실행할 프로세스를 선택
    - 여러 개의 처리기가 공동 자료 구조를 접근하여 갱신 가능
    - 거의 모든 현대 운영체제들은 SMP를 지원

### 처리기 친화성 (Processor Affinity)

SMP 시스템이 한 처리기에서 다른 처리기의 이주를 피하고 대신 같은 처리기에서 프로세스를 시도하는 것

- 이주 시 캐시를 무효화 하고 다시 채우는 비용이 많이 들기 때문
- **약한 친화성 (soft affinity)** : OSrk rkxdms 프로세스를 실행시키려고 노력하는 정책을 가지고 있지만 보장하지는 않음
- **강한 친화성 (hard affinity)** : 시스템 호출을 통하여 프로세스가 다른 처리기로 이주되 않도록 지정

### 부하 균등화 (Load Balancing)

부하 균등화(load balancing)sms SMP 시스템의 모든 처리기 사이에 부하가 고르게 배분되도록 시도

- push 이주 (migration)
    - 특정 태스크가 주기적으로 각 처리기의 부하를 검사
    - 만일 불균형 상태로 밝혀지면 과부하인 처리기에서 쉬고 있거나 덜 바쁜 처리기로 프로세스를 이동시킴으로써 부하 분배
- pull 이주
    - 쉬고 있는 처리기가 바쁜 처리기를 기다리고 있는 프로세스를 pull할 때 발생
- Linux는 200밀리초마다 또는 실행 큐가 비게 되면 자신의 부하 균등화 알고리즘을 실행

# 다중 코어 프로세서 (Multicore Processors)

최근의 경향은 하나의 물리적인 칩 안에 여러 개의 처리기 코어를 장착

- 속도가 빠르고 적은 전력 소모
- SMT(Simultaneous Multithreading), Hyperthreading
- 코어 당 다수의 스레드 스케줄
    - 한 스레드의 메모리 멈춤(memory stall) 시 다른 스레드 스케줄

### 일시적 멀티스레딩과 동시 멀티스레딩

- 일시적 멀티스레딩 (Temporal Multithreading. TMT) : 한 번에 하나의 스레드에서만 명령어를 실행하거나 작업을 수행할 수 있음
    - 시분할 멀티스레딩이라고도 함
    - 멀티스레딩, 싱글코어 싱글스레드에 적용 가능
- 동시 멀티스레딩(Simultaneous Multithreading, SMT) : 여러 스레드들을 한꺼번에 명령어들을 실행하거나 작업들을 수행할 수 있음'
    - 완전하게 병행 처리, 병렬 처리가 가능

# 실시간 CPU 스케줄링 (Real-Time CPU Scheduling)

- 마감시한 내의 태스크 서비스 보장 유무에 따라 연성 실시간 시스템(soft real-time system), 경성 실시간 시스템(hard real-time system)으로 구분
- 두 가지의 지연이 성능에 영향
    - 인터럽트 지연 : 인터럽트 도착에서부터 인터럽트 서비스까지의 시간
    - 디스패치 지연 : 현재 프로세스가 CPU에서 물러나고 다른 프로세스를 스케줄하는 시간
    - 디스패치 지연 시, 충돌 단계는 두 가지
        - 커널 모드에서 실행되고 있는 어떤 프로세스를 선점
        - 높은 우선순위의 프로세스가 필요한 자원을 낮은 우선 순위 프로세스 자원이 해제
  
    
- 실시간 운영체제의 스케줄러는 선점을 이용한 우선 순위 기반의 스케줄링 알고리즘을 지원
- 실시간 운영체제의 프로세스 특성
    - 프로세스들이 주기적이고 일정한 간격으로 CPU를 필요로 함
    - 각 프로세스는 고정된 수행시간 t, 마감시간 d, 주기 p가 정해져 있음
    - 0 ≤ t ≤ d ≤ d ≤ p

### Rate Mocotonic (비율 단조) 스케줄링

선점 가능한 정적 우선순위 정책 사용하여 주기적인 태스크 스케줄

- 주기에 반비례하여 우선순위 배정
- 주기가 짧으면 높은 우선순위, 길면 낮은 우선순위가 배정
- CPU 이용률 한계로 CPU 자원을 최대화하여 사용하는 것이 불가능리눅

### Earliest-Deadline-First (EDF) 스케줄링

Earliest-Deadline-First (EDF) 스케줄링은 마감 시간에 따라 우선순위를 **동적**으로 부여

- 마감시간이 빠를수록 우선순위는 높고, 늦을수록 낮아짐
- 모든 프로세스가 마감시간을 만족하도록 스케줄링이 가능

### 일정 비율의 몫 스케줄링(propotional share scheduling)

일정 비율의 몫 스케줄링(propotional share scheduling)은 모든 응용들에게 T의 시간의 몫을 할당

- 한 응용이 N의 시간 몫을 할당 받으면, 모든 프로세스의 시간 중 N/T 시간을 할당 받게 됨
- ex)  A B C 3개의 프로세스, T=100일 때
    - A = 50, B = 15, C = 20의 시간의 몫 할당 → A는 처리기의 50%, B는 15%, C는 20% 할당
    - 새로운 프로세스 D가 30의 시간의 몫 요구 시 승인 제어기는 D 진입을 거부

# 리눅스 스케줄링

- 리눅스 커널 버전 2.5는 O(1) 상수 복잡도의 스케줄링 시간
    - 선점형, 우선순위 기반
    - 두 가지 우선 순위 영역 : 시분할, 실시간
    - 우선 순위가 높을 수록 더 큰 시간 조각을 부여
    - 시간 조각이 남아 있는 길이 만큼 태스크는 실행 가능
    - 시간 조각이 남아 있느 않으면, 모든 다른 태스크들이 자신의 시간 조각을 다 사용할 때까지 실행 가능하지 않음
- 리눅스 스케줄링 버전 2.6.23+
    - CFS(Completely Fair Scheduler)
    - 스케줄링 클래스
        - 각 태스크는 특정 우선순위 가짐
        - 스케줄러는 가장 높은 우선순위 클래스에서 가장 높은 우선순위의 태스크를 선택
        - 고정된 시간 조각 할당 보다는 CPU 시간에 비례하여 시간 조각 지정
    - CFS는 태스크 당 가상 실행시간 관리
    - 리눅스 CFS 스케줄러는 모든 실행 가능한 태스크는 키 갑승로 vruntime을 가즌ㄴ 균형 이진 탐색 트리인 레드-블랙 트리를 구성하여 관리
