### 2차 기회 알고리즘(Second-Chance Algorithm)

- 참조 비트 사용하고 클록 교체(clock replacement)라고도 함
- 교체될 페이지를 순서대로 조사
    - 참조 비트가 1이면 0으로 세트하고 한 번 더 기회를 줌
    - 참조 비트가 0이면 해당 페이지를 교체
- 순환 큐(circular queue)를 사용하여 구현
    - 포인터(시계의 침)가 다음에 교체될 페이지를 가리킴

### 개선된 2차 기회 알고리즘 (Enhanced Second-Chance Algorithm)

- (참조비트, 변경비트) 두 개의 비트를 조합하여 등급을 설정
    - (0, 0) 최근에 사용되지도 변경되지도 않은 경우 : 교체하기 가장 좋은 페이지
    - (0, 1) 최근에 사용되지는 않았지만 변경은 된 경우 : 이 페이지가 교체되면 디스크에 내용을 기록해야 하기 때문에 교체에 적당하지 않음
    - (1, 0) 최근에 사용은 되었으나 변경은 되지 않은 경우 : 이 페이지는 곧 다시 사용될 가능성이 높음
    - (1, 1) 최근에 사용도 되었고 변경도 된 경우 : 아마 곧 다시 사용될 것이며 교체되면 역시 디스크에 그 내용을 먼저 기록해야 함
- 페이지 교체가 필요할 때 클록 알고리즘과 같은 방법을 사용
    - 가장 낮은 등급을 가지면서 처음 만난 페이지를 교체

### 계수-기반 페이지 교체 (Counting-Based Page Replacement)

- 각 페이지를 참조할 때마다 계수(count)
- **LFU (Least Frequently Used) 알고리즘**
    - 참조 횟수가 가장 작은 페이지를 교체
    - 프로세스가 초기 단계에서는 한 페이지를 집중적으로 사용 후 다시 사용하지 않은 경우에 판단 틀림 : 참조 횟수를 일정한 시간마다 하나씩 오른쪽으로 이동해서 지수적으로 그 영향력을 감소시켜서 해결
- **MFU (Most Frequently User) 알고리즘**
    - 가장 작은 참조 횟수를 가진 페이지가 가장 최근 참조된 것이고 앞으로 사용될 것이라는 판단에 근거

### 페이지-버퍼링 알고리즘 (Page-Buffering Algorithms)

- 페이지 교체 알고리즘과 병행하여 적용
- 가용 프레임 여러 개를 풀(pool)에 저장 (버퍼링)
- 가용 프레임 풀은 유지하면서 프레임의 임자 페이지를 기억할 수도 있음
    - 이 프레임을 재 참조 시 디스크를 읽을 필요 없음
    - 희생될 페이지를 잘못 선정한 경우 유용

# 페이지 교체 응용

- 앞의 모든 알고리즘들은 페이지의 향후 사용을 예측하여 동작
- 일부 응용들은 메모리 사용 동작에 대해 많은 지식을 가짐 : DB 응용 등
- 메모리를 많이 사용하는 범용 응용들은 이 중으로 버퍼링
    - OS가 입출력 버퍼 등과 같은 메모리에 페이지를 복사
    - 응용은 자신의 작업을 위해 페이지를 메모리에 유지
- 특수한 응용들을 위해 운영체제는 디스크에 직접 접근하는 수단을 제공
    - raw disk mode (?)
    - 파일 시스템의 요구 페이징, 파일 잠금, 버퍼링 등의 서비스를 우회(bypass)

## 프레임의 할당 (Allocation of Frame)

- 각 프로세스에게 할당해야 하는 프레임 수 결정
    - 각 프로세스 당 필요한 최소의 프레임 수는 아키텍처에 의해 결정
    - 각 프로세스 당 최대 할당 프레임 수는 가용물리 메모리에 의해 결정
    

## 할당 알고리즘 (allocation algorithm)

- 균등 할당 (equal allocation)
    - 모든 프로세스에게 똑같이 할당
    - ex) 5개의 프로세스, 93개 프레임 : 18개 씩(18*5=90), 3개의 자유 프레임 버퍼 풀
- 비례 할당 (proportional allocation)
    - 각 프로세스의 크기 비율에 맞추어 할당
- 우선순위 할당 (priority allocation)
    - 비례 할당 방법을 사용하면서 프레임 비율을 프로세스의 크기가 아닌 우선순위를 사용하여 또는 크기와 우선순위의 조합을 사용하여 결정

## 전역 대 지역 할당 (Global Versus Local Allocation)

- **전역 교체 (global replacement)**
    - 교체할 프레임을 다른 프로세스에 속한 프레임을 포함한 모든 프레임을 대상으로 찾는 경우
    - 프로세스 실행 시간이 크게 변함
    - 높은 메모리 이용율
- **지역 교체 (local replacement)**
    - 각 프로세스가 자기에게 할당된 프레임들 중에서만 교체될 희생자를 선택
    - 일관된 프로세스의 성능
    - 낮은 메모리 이용율

# 비균등 메모리 접근 (Non-Uniform Memory Access)

- 위는 모든 주 메모리에 동등하게 접근한다는 가정
- 메모리 접근 시간이 차이가는 NUMA(Non-Uniform Memory Access) 시스템
    - CPU와 메모리가 같은 보드인 경우 접근
    - 시스템 버스로 상호 연결된 메모리에 접근
- 프로세스(스레드)가 실행 중인 CPU에 가장 가까운 메모리 프로세임에 할당하는 것이 최적의 성능
    - 스케줄러가 가능하면 같은 시스템 보드 상에 스레드를 스케줄
    - Solaris lgroup이라는 개체를 생성하여 해결
        - CPU/메모리 지연이 작은 그룹들을 추적
        - 프로세스의 모든 스레드와 메모리 할당을 lgroup 단위로 처리
