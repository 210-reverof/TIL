# 기본 하드웨어

각각의 프로세스는 독립된 메모리 공간을 가짐

- 특정 프로세스만 접근할 수 있는 합법적인 메모리 주소 영역을 설정
- 프로세스가 합법적인 영역만을 접근하도록 보호하는 것이 필요
- 메모리 공간의 보호는 CPU 하드웨어가 사용자 모드에서 만들어진 모든 주소와 레지스터를 비교함으로써 이루어짐
    - 베이스(base) 레지스터와 상한(limit) 레지스터 사용
    - 베이스 레지스터는 가장 작은 합법적인 물리 메모리 주소의 값을 저장
    - 상한 레지스터는 주어진 영역의 크기를 저장

# 주소의 할당(Address Binding)

프로그렘이 실행되기 위해서는 메인 메모리에 적재되어 프로세스가 되어야 함 : 프로그램은 원래 이진 실행 파일 형태로 디스크에 저장

- 입력 큐(input queue) : 디스크에서 메인 메모리에 적재되기를 기다리고 있는 프로세스들의 집합
    - 큐에서 하나의 프로세스를 선택해서, 메모리에 적재 후 실행하고, 프로세스가 실행되는 동안 메모리에서 명령어와 자료를 액세스
- 주소는 각 단계에서 다양하게 표현
    - 소스 코드에서는 심볼(변수)로 표시
    - 컴파일된 코드에서는 재배치 가능한 주소(relocatable address)로 바인딩
    - 링커나 로더는 재배치 가능한 주소를 절대주소로 바인딩
    - 각 바인딩 과정은 한 주소 공간에서 다른 주소 공간으로 맵핑

# 메모리 주소 공간에서 명령어와 자료의 바인딩

메모리 주소 공간에서 명령어와 자료의 바인딩은 이루어지는 시점에 따라 다음과 같이 구분

- 컴파일 시간(Compile time) 바인딩
    - 만일 프로세스가 메모리 내에 들어갈 위치를 컴파일 시간에 미리 알 수 있으면 컴파일러는 절대 코드를 생성할 수 있음
    - 만일 이 위치가 변경되어야 한다면 이 코드는 다시 컴파일 되어야 함
    - MS-DOS의 .COM 양식 프로그램
- 적재 시간(Load time) 바인딩
    - 만일 프로세스가 메모리 위치를 컴파일 시점에 알지 못하면 컴파일러는 일단 이진 코드를 재배치 가능 코드(relocatable code)로 만들어야 함
- 실행 시간(Excution time) 바인딩
    - 만약 프로세스가 실행하는 중간에 메모리 내의 한 세그먼트로부터 다른 세그먼트를 옮겨질 수 있다면 바인딩이 실행 시간까지 지연
    - 특별한 하드웨어 지원이 필용 : 베이스(base) 레지스터와 상한(limit) 레지스터 사용

# 논리 대 물리 주소 공간 (Logical Versus Physical Address Space)

- 논리 주소(logical address) : CPU(프로그램)가 생성하는 주소
- 물리 주소(physical address) : 메모리가 취급하게 되는 주소(즉, 메모리 주소 레지스터(MAR)에 주어지는 주소)
- 컴파일 시 바인딩과 적재 시의 바인딩 기법 : 논리, 물리 주소 동일
- 실행 시간 바인딩 기법 : 논리, 물리 주소가 다름 → 가상주소(virtual address)

# 메모리 관리 장치(MMU, Memory Management Unit)

가상 주소를 물리 주소로 변환(mapping) 하는 하드웨어 장치

- MMU 방식에서는 사용자 프로세스에 의해 생성된 모든 주소에 재배치(relocation) 레지스터의 값이 더해짐
- 재배치 레지스터는 앞에서 기술한 일종의 기준 레지스터(base register)
- 사용자 프로그램은 논리 주소만을 다루고 실제적인 물리 주소를 알 수 없음
    - 메모리 참조할 때 실행 시간 바인딩 발생
    - 논리 주소가 물리 주소 변환

# 동적 적재 (Dynamic Loading)

- 동적 적재에서 각 루틴은 실제 호출되기 전까지는 메모리에 올라오지 않고 재배치 가능한 상태로 디스크에서 대기
    - 향상된 메모리 공간 활용
    - 사용되지 않은 루틴은 메모리에 적재되지 않음
    - 오류 처리 루틴과 같이 아주 간혹 발생하면서도 많은 양의 코드를 필요로 하는 경우에 유용
- 동적 적재는 운영체제로부터 특별한 지원을 필요로 하지 않음
    - 사용자 자신이 프로그램의 설계를 책임
    - 운영체제는 동적 적재를 구현하는 라이브러리 루틴을 제공 가능

# 동적 연결 및 공유 라이브러리 (Dynamic Linking & Shared Library)

- 정적 연결(static linking)
- 동적 연결에서는 연결(linking)이 실행 시기까지 연기
    - 동적 연결은 주로 공유 라이브러리(shared library)에 사용
    - 동적 연결을 지원하지 않으면 모든 시스템 라이브러리를 부르는 프로그램들은 그들의 이진 프로그램 이미지 내에 시스템 라이브러리 루틴들을 한 부씩 가지고 있어야 함
- 작은 코드 조각인 스텁(stub)을 사용하여 메모리에 적재된 라이브러리의 위치를 찾음
    - 라이브러리가 메모리에 없으면 디스크에서 가져옴
    - 스텁 자신을 찾은 루친의 번지로 대체하고, 실행

# 스와핑 (Swapping)

프로세스는 실행 도중에 임시로 보조 메모리(디스크)에 보내어졌다가 다시 메모리로 되돌아 오는 것을 스와핑이라고 함

- 스와핑은 우선순위 기반 스케줄링 알고리즘에 적용될 수 있음
    - 낮은 우선순위 프로세스를 디스크로 스왑
    - 높은 우선순위 프로세스가 끝나면, 낮은 우선순위 프로세스는 다시 메모리로 스왑
    - 우선순위 기반 알고리즘에서 사용되는 스와핑의 변형을 롤 인(roll-in), 롤 아웃(roll-out)이라고 함
- 스왑 시간의 대부분이 디스크 전송 시간 : 전송 시간은 스왑될 메모리의 크기와 비례

# 연속 메모리 할당 (Contiguous Memory Allocation)

- 메모리는 일반적으로 두 개의 부분으로 분할
    - 메모리에 상주하는 운영체제로, 일반적으로 인터럽트 벡터와 함께 하위 메모리에 위치
    - 상위 메모리에 있는 사용자 프로세스들
- 연속 메모리 할당 시스템에서는 각 프로세스는 연속된 메모리 공간을 차지
- 메모리 사상과 보호
    - 재배치 레지스터와 상한 레지스터(limit register)에 의해 수행

- 메모리 할당 (memory allocation)
    - 고정된 크기로 분할(single partition)
    - 서로 다른 크기로 분할(가변 분할, multiple partition)
        - 사용 가능한 메모리 블록인 공간(hole)의 크기가 다양하며 메모리에 분산
        - 새로 프로세스가 도착하면 이를 수용할 수 있는 충분한 크기의 공간을 할당
        - 운영체제는 할당된 분할과 가용한 분할(hole)에 관한 정보를

# 동적 메모리 할당 문제 (Dynamic Storage Allocation Problem)

일련의 공간들-리스트로부터 크기 n-바이트 블록을 요구하는 것을 어떻게 만족시켜 줄 것이냐를 결정하는 문제

- 최초 적합(first-fit)
    - 첫 번째 사용 가능한 공간을 할당
- 최적 적합 (best-fit)
    - 사용 가능한 공간들 중에서 가장 작은 것을 선택
    - 리스트가 정렬 되어 있지 않다면 전 리스트를 검색
    - 많은 작은 공간들이 생성
- 최악 적합 (worst-fit)
    - 가장 큰 공간을 선택
    - 리스트가 정렬 되어 있지 않다면 전 리스트를 탐색
    - 할당해 주고 남게 되는 공간을 충분히 커서 다른 프로세스들을 위하여 유용하게 사용
- 최초 적합과 최적 적합 모두가 시간과 메모리 이용 효율 측면에서 최악 적합보다 좋다는 것이 입증

# 단편화 (Fragmentation)

단편화는 공간 중 일부가 사용 못하게 되는 것을 말함

- 외부 단편화 (external fragmentaion) : 유효 공간들을 모두 합치면 충분한 공간이 되지만, 그것들이 너무 작은 조각들로 여러 곳에 분산되어 있을 때 발생
- 내부 단편화 (internal fragmentation) : 일반적으로 메모리는 공정된 크기의 정수 배로 할당되어 할당된 공간이 요구된 공간보다 약간 더 클 수 있음
- 외부 단편화는 압축(compaction)을 하여 해결
    - 메모리 모든 내용들을 한 군데로 몰고 모든 자유 공간들을 다른 한 군데로 몰아서 큰 블록을 생성
    - 압축은 프로세스들의 재배치가 실행 시간에 동적으로 이루어지는 경우에만 가능
